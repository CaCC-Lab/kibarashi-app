# ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆå®Ÿè£…ã‚¬ã‚¤ãƒ‰
## é©æ–°çš„æ©Ÿèƒ½ã®å³åº§å®Ÿè£…ã®ãŸã‚ã®æŠ€è¡“æŒ‡å—

æœ€çµ‚æ›´æ–°: 2025å¹´6æœˆ29æ—¥  
å¯¾è±¡: é–‹ç™ºè€…å‘ã‘å³åº§å®Ÿè£…ã‚¬ã‚¤ãƒ‰

---

## ğŸš€ ä»Šã™ãå®Ÿè£…é–‹å§‹ï¼

### 1åˆ†ã§é–‹å§‹ã§ãã‚‹æœ€å„ªå…ˆå®Ÿè£…

```bash
# Phase 4.1 é–‹ç™ºãƒ–ãƒ©ãƒ³ãƒä½œæˆ
git checkout -b feature/phase-4-innovations

# å¿…è¦ä¾å­˜é–¢ä¿‚ã®ä¸€æ‹¬ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install @tensorflow/tfjs natural sentiment compromise ssml-builder
npm install --save-dev @types/dom-speech-recognition

# æ–°æ©Ÿèƒ½ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ä½œæˆ
mkdir -p src/features/{cognitive-reframing,mood-input,smart-nudging}
mkdir -p src/components/advanced-ui/{emotion-canvas,voice-controls}
mkdir -p src/services/{ml-prediction,advanced-tts,privacy-engine}
mkdir -p src/utils/{emotion-analysis,behavioral-prediction}

echo "ğŸ¯ Phase 4.1 é–‹ç™ºç’°å¢ƒæº–å‚™å®Œäº†ï¼"
```

---

## ğŸ”¥ æœ€å„ªå…ˆå®Ÿè£…: ãƒã‚¬ãƒ†ã‚£ãƒ–æ„Ÿæƒ…ãƒªãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³

### Step 1: åŸºç›¤å‹å®šç¾© (5åˆ†)

```typescript
// src/features/cognitive-reframing/types.ts
export interface EmotionReframingRequest {
  emotionType: 'ã‚¤ãƒ©ã‚¤ãƒ©' | 'ãƒ¢ãƒ¤ãƒ¢ãƒ¤' | 'ä¸å®‰' | 'ç–²ã‚Œ' | 'è½ã¡è¾¼ã¿';
  situation: 'meeting' | 'email' | 'presentation' | 'deadline' | 'interpersonal';
  intensity: number; // 1-10 scale
  availableTime: number; // minutes
  workContext: {
    isInOffice: boolean;
    canUseAudio: boolean;
    privacyLevel: 'high' | 'medium' | 'low';
  };
}

export interface CognitiveReframingStrategy {
  name: string;
  description: string;
  technique: 'evidence-challenge' | 'perspective-shift' | 'self-compassion' | 'action-focus';
  targetEmotions: string[];
  estimatedEffectiveness: number; // 0-1
}

export interface ReframingResponse {
  strategy: CognitiveReframingStrategy;
  personalizedScript: string;
  guidedQuestions: string[];
  breathingCue: string;
  affirmation: string;
  audioSSML?: string;
  followUpSuggestions: string[];
}
```

### Step 2: CBTæˆ¦ç•¥å®Ÿè£… (15åˆ†)

```typescript
// src/features/cognitive-reframing/strategies.ts
export const CBT_STRATEGIES: Record<string, CognitiveReframingStrategy> = {
  evidenceChallenge: {
    name: "äº‹å®Ÿæ¤œè¨¼æ³•",
    description: "æ„Ÿæƒ…ã®æ ¹æ‹ ã¨ãªã‚‹äº‹å®Ÿã‚’å†·é™ã«æ¤œè¨¼ã™ã‚‹",
    technique: "evidence-challenge",
    targetEmotions: ["ã‚¤ãƒ©ã‚¤ãƒ©", "ä¸å®‰", "è½ã¡è¾¼ã¿"],
    estimatedEffectiveness: 0.85
  },
  
  perspectiveShift: {
    name: "è¦–ç‚¹è»¢æ›æ³•", 
    description: "ä»–è€…ã®è¦–ç‚¹ã‚„å°†æ¥ã®è¦–ç‚¹ã‹ã‚‰çŠ¶æ³ã‚’è¦‹ç›´ã™",
    technique: "perspective-shift",
    targetEmotions: ["ãƒ¢ãƒ¤ãƒ¢ãƒ¤", "ã‚¤ãƒ©ã‚¤ãƒ©", "è½ã¡è¾¼ã¿"],
    estimatedEffectiveness: 0.78
  },
  
  selfCompassion: {
    name: "è‡ªå·±æ…ˆæ‚²æ³•",
    description: "è‡ªåˆ†è‡ªèº«ã«å„ªã—ãæ¥ã—ã€å®Œç’§ä¸»ç¾©ã‚’æ‰‹æ”¾ã™", 
    technique: "self-compassion",
    targetEmotions: ["è½ã¡è¾¼ã¿", "ç–²ã‚Œ", "ä¸å®‰"],
    estimatedEffectiveness: 0.82
  },
  
  actionFocus: {
    name: "è¡Œå‹•è»¢æ›æ³•",
    description: "æ„Ÿæƒ…ã‚’å»ºè¨­çš„ãªè¡Œå‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¤‰æ›ã™ã‚‹",
    technique: "action-focus", 
    targetEmotions: ["ã‚¤ãƒ©ã‚¤ãƒ©", "ãƒ¢ãƒ¤ãƒ¢ãƒ¤", "ç–²ã‚Œ"],
    estimatedEffectiveness: 0.75
  }
};

export class CognitiveReframingEngine {
  selectOptimalStrategy(request: EmotionReframingRequest): CognitiveReframingStrategy {
    const applicableStrategies = Object.values(CBT_STRATEGIES)
      .filter(strategy => strategy.targetEmotions.includes(request.emotionType))
      .sort((a, b) => b.estimatedEffectiveness - a.estimatedEffectiveness);
    
    // çŠ¶æ³ã«å¿œã˜ãŸæˆ¦ç•¥èª¿æ•´
    if (request.situation === 'meeting' && request.intensity > 7) {
      return applicableStrategies.find(s => s.technique === 'evidence-challenge') || applicableStrategies[0];
    }
    
    if (request.availableTime < 3) {
      return applicableStrategies.find(s => s.technique === 'self-compassion') || applicableStrategies[0];
    }
    
    return applicableStrategies[0];
  }
}
```

### Step 3: Geminiçµ±åˆå®Ÿè£… (10åˆ†)

```typescript
// src/features/cognitive-reframing/gemini-integration.ts
export class GeminiReframingService {
  private readonly REFRAMING_PROMPTS = {
    evidenceChallenge: `
ã‚ãªãŸã¯è·å ´ã®ã‚¹ãƒˆãƒ¬ã‚¹è§£æ¶ˆã«ç‰¹åŒ–ã—ãŸèªçŸ¥è¡Œå‹•ç™‚æ³•ã®ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã§ã™ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®çŠ¶æ³:
- æ„Ÿæƒ…: {emotionType}
- çŠ¶æ³: {situation}  
- å¼·åº¦: {intensity}/10
- åˆ©ç”¨å¯èƒ½æ™‚é–“: {availableTime}åˆ†

ä»¥ä¸‹ã®å½¢å¼ã§ã€å„ªã—ãå…±æ„Ÿçš„ã§å®Ÿç”¨çš„ãªãƒªãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ã‚’ä½œæˆã—ã¦ãã ã•ã„:

1. å…±æ„Ÿçš„ãªå£°ã‹ã‘ (20æ–‡å­—ä»¥å†…)
2. äº‹å®Ÿã®æ•´ç†ã‚’ä¿ƒã™è³ªå• (1ã¤)
3. åˆ¥ã®è¦–ç‚¹ã®æç¤º (å…·ä½“çš„ã§å»ºè¨­çš„)
4. æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®èª˜å° (è·å ´ã§å®Ÿè·µå¯èƒ½)
5. åŠ±ã¾ã—ã®è¨€è‘‰ (15æ–‡å­—ä»¥å†…)

å£èª¿: è¦ªã—ã¿ã‚„ã™ãã€æŠ¼ã—ä»˜ã‘ãŒã¾ã—ããªã„
åˆ¶ç´„: è·å ´ã§{availableTime}åˆ†ä»¥å†…ã«å®Ÿè·µå¯èƒ½ãªå†…å®¹
`,

    perspectiveShift: `
è·å ´ã§ã®ã‚¹ãƒˆãƒ¬ã‚¹çŠ¶æ³ã«å¯¾ã—ã¦ã€è¦–ç‚¹è»¢æ›ã‚’é€šã˜ãŸå¿ƒç†çš„ã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚

ç¾åœ¨ã®çŠ¶æ³: {emotionType}ã‚’{intensity}/10ã®å¼·åº¦ã§æ„Ÿã˜ã¦ã„ã‚‹
çŠ¶æ³è©³ç´°: {situation}
æ™‚é–“åˆ¶ç´„: {availableTime}åˆ†

ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã§è¦–ç‚¹è»¢æ›ã‚¬ã‚¤ãƒ‰ã‚’ä½œæˆ:

1. ç¾åœ¨ã®æ„Ÿæƒ…ã¸ã®å…±æ„Ÿ (ã€Œå¤§å¤‰ã§ã—ãŸã­ã€ãªã©)
2. æ™‚é–“è»¸ã®æ‹¡å¼µ ("1å¹´å¾Œã«ã¯..." "ã“ã®çµŒé¨“ãŒ...")
3. ä»–è€…è¦–ç‚¹ã®å°å…¥ ("ã‚‚ã—åŒåƒšãŒåŒã˜çŠ¶æ³ãªã‚‰...")
4. å­¦ç¿’æ©Ÿä¼šã¨ã—ã¦ã®å†å®šç¾©
5. å‰å‘ããªè¡Œå‹•ã¸ã®èª˜å°

å¿…é ˆ: æ—¥æœ¬ã®è·å ´æ–‡åŒ–ã«é…æ…®ã—ã€è‡ªç„¶ã§å—ã‘å…¥ã‚Œã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ç”¨
`
  };

  async generateReframing(request: EmotionReframingRequest): Promise<ReframingResponse> {
    const strategy = new CognitiveReframingEngine().selectOptimalStrategy(request);
    const prompt = this.REFRAMING_PROMPTS[strategy.technique];
    
    const personalizedPrompt = this.substituteVariables(prompt, request);
    
    try {
      const geminiResponse = await fetch('/api/gemini/reframing', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt: personalizedPrompt })
      });
      
      const content = await geminiResponse.json();
      
      return {
        strategy,
        personalizedScript: content.script,
        guidedQuestions: content.questions,
        breathingCue: this.generateBreathingCue(request.intensity),
        affirmation: content.affirmation,
        audioSSML: this.generateSSML(content.script, request),
        followUpSuggestions: content.followUp
      };
    } catch (error) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: äº‹å‰å®šç¾©ã•ã‚ŒãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
      return this.getFallbackReframing(request, strategy);
    }
  }

  private generateBreathingCue(intensity: number): string {
    if (intensity >= 8) return "æ·±ãæ¯ã‚’å¸ã£ã¦(4ç§’)ã€ã‚†ã£ãã‚Šåã„ã¦ãã ã•ã„(8ç§’)";
    if (intensity >= 5) return "è‡ªç„¶ãªå‘¼å¸ã«æ„è­˜ã‚’å‘ã‘ã¦ã€3å›æ·±å‘¼å¸ã—ã¾ã—ã‚‡ã†";
    return "è»½ãæ·±å‘¼å¸ã‚’ã—ã¦ã€è‚©ã®åŠ›ã‚’æŠœã„ã¦ãã ã•ã„";
  }

  private generateSSML(script: string, request: EmotionReframingRequest): string {
    const rate = request.intensity > 7 ? 'slow' : 'medium';
    const pitch = request.emotionType === 'è½ã¡è¾¼ã¿' ? '+2Hz' : 'default';
    
    return `
      <speak>
        <prosody rate="${rate}" pitch="${pitch}">
          <p>
            <s>${script.split('ã€‚')[0]}ã€‚</s>
            <break time="1s"/>
            <s>${script.split('ã€‚').slice(1).join('ã€‚')}</s>
          </p>
        </prosody>
      </speak>
    `;
  }
}
```

---

## ğŸ¨ æ¬¡å„ªå…ˆ: ã‚¼ãƒ­UIãƒ»ãƒ ãƒ¼ãƒ‰å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ 

### Step 1: æ„Ÿæƒ…åº§æ¨™ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (10åˆ†)

```typescript
// src/components/advanced-ui/emotion-canvas/EmotionCanvas.tsx
import React, { useRef, useEffect, useState, useCallback } from 'react';

interface EmotionalCoordinates {
  valence: number; // -1.0 (negative) to +1.0 (positive)
  arousal: number; // -1.0 (calm) to +1.0 (energetic)
}

interface EmotionCanvasProps {
  onEmotionChange: (emotion: EmotionalCoordinates) => void;
  onSelectionComplete: (emotion: EmotionalCoordinates) => void;
}

export const EmotionCanvas: React.FC<EmotionCanvasProps> = ({
  onEmotionChange,
  onSelectionComplete
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [currentEmotion, setCurrentEmotion] = useState<EmotionalCoordinates>({ valence: 0, arousal: 0 });
  const [isInteracting, setIsInteracting] = useState(false);

  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const centerX = width / 2;
    const centerY = height / 2;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw background gradient
    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) / 2);
    gradient.addColorStop(0, 'rgba(124, 58, 237, 0.1)');
    gradient.addColorStop(1, 'rgba(124, 58, 237, 0.05)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Draw axis lines
    ctx.strokeStyle = 'rgba(156, 163, 175, 0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    
    // Horizontal line (valence axis)
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(width, centerY);
    ctx.stroke();

    // Vertical line (arousal axis)
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, height);
    ctx.stroke();

    ctx.setLineDash([]);

    // Draw quadrant labels
    ctx.fillStyle = 'rgba(107, 114, 128, 0.6)';
    ctx.font = '12px Inter, system-ui, sans-serif';
    ctx.textAlign = 'center';
    
    ctx.fillText('ã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥', centerX, 20);
    ctx.fillText('ç©ã‚„ã‹', centerX, height - 10);
    
    ctx.save();
    ctx.translate(15, centerY);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('ãƒã‚¬ãƒ†ã‚£ãƒ–', 0, 0);
    ctx.restore();
    
    ctx.save();
    ctx.translate(width - 15, centerY);
    ctx.rotate(Math.PI / 2);
    ctx.fillText('ãƒã‚¸ãƒ†ã‚£ãƒ–', 0, 0);
    ctx.restore();

    // Draw emotion indicators in quadrants
    const indicators = [
      { text: 'èˆˆå¥®ãƒ»æ´»åŠ›', x: centerX + 60, y: centerY - 60, emoji: 'âš¡' },
      { text: 'ãƒªãƒ©ãƒƒã‚¯ã‚¹ãƒ»æº€è¶³', x: centerX + 60, y: centerY + 60, emoji: 'ğŸ˜Œ' },
      { text: 'ã‚¤ãƒ©ã‚¤ãƒ©ãƒ»ç„¦ã‚Š', x: centerX - 60, y: centerY - 60, emoji: 'ğŸ˜¤' },
      { text: 'è½ã¡è¾¼ã¿ãƒ»ç–²ã‚Œ', x: centerX - 60, y: centerY + 60, emoji: 'ğŸ˜”' }
    ];

    ctx.font = '10px Inter, system-ui, sans-serif';
    ctx.textAlign = 'center';
    indicators.forEach(indicator => {
      ctx.fillStyle = 'rgba(107, 114, 128, 0.4)';
      ctx.fillText(indicator.emoji, indicator.x, indicator.y - 10);
      ctx.fillText(indicator.text, indicator.x, indicator.y + 5);
    });

    // Draw current position
    const x = centerX + currentEmotion.valence * (width / 2 - 20);
    const y = centerY - currentEmotion.arousal * (height / 2 - 20);

    // Glow effect
    const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, 20);
    glowGradient.addColorStop(0, 'rgba(124, 58, 237, 0.4)');
    glowGradient.addColorStop(1, 'rgba(124, 58, 237, 0)');
    ctx.fillStyle = glowGradient;
    ctx.fillRect(x - 20, y - 20, 40, 40);

    // Main point
    ctx.beginPath();
    ctx.arc(x, y, isInteracting ? 12 : 8);
    ctx.fillStyle = '#7c3aed';
    ctx.fill();
    
    // Inner highlight
    ctx.beginPath();
    ctx.arc(x, y, isInteracting ? 6 : 4);
    ctx.fillStyle = '#a855f7';
    ctx.fill();

  }, [currentEmotion, isInteracting]);

  useEffect(() => {
    drawCanvas();
  }, [drawCanvas]);

  const handleInteraction = useCallback((clientX: number, clientY: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const valence = Math.max(-1, Math.min(1, (x - rect.width / 2) / (rect.width / 2 - 20)));
    const arousal = Math.max(-1, Math.min(1, -(y - rect.height / 2) / (rect.height / 2 - 20)));

    const newEmotion = { valence, arousal };
    setCurrentEmotion(newEmotion);
    onEmotionChange(newEmotion);
  }, [onEmotionChange]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    setIsInteracting(true);
    handleInteraction(e.clientX, e.clientY);
  }, [handleInteraction]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isInteracting) return;
    handleInteraction(e.clientX, e.clientY);
  }, [isInteracting, handleInteraction]);

  const handleMouseUp = useCallback(() => {
    if (isInteracting) {
      setIsInteracting(false);
      onSelectionComplete(currentEmotion);
    }
  }, [isInteracting, currentEmotion, onSelectionComplete]);

  // Touch events
  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    setIsInteracting(true);
    const touch = e.touches[0];
    handleInteraction(touch.clientX, touch.clientY);
  }, [handleInteraction]);

  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    if (!isInteracting) return;
    const touch = e.touches[0];
    handleInteraction(touch.clientX, touch.clientY);
  }, [isInteracting, handleInteraction]);

  const handleTouchEnd = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    if (isInteracting) {
      setIsInteracting(false);
      onSelectionComplete(currentEmotion);
    }
  }, [isInteracting, currentEmotion, onSelectionComplete]);

  return (
    <div className="relative w-full max-w-md mx-auto">
      <canvas
        ref={canvasRef}
        width={320}
        height={320}
        className="w-full h-auto cursor-pointer touch-none border border-gray-200 rounded-xl shadow-sm"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
      />
      
      <div className="mt-4 text-center">
        <p className="text-sm text-gray-600">
          ã‚¿ãƒƒãƒ—ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç¾åœ¨ã®æ°—æŒã¡ã‚’é¸æŠ
        </p>
        <div className="mt-2 text-xs text-gray-500">
          é¸æŠ: <span className="font-medium">
            {currentEmotion.valence > 0.3 ? 'ãƒã‚¸ãƒ†ã‚£ãƒ–' : 
             currentEmotion.valence < -0.3 ? 'ãƒã‚¬ãƒ†ã‚£ãƒ–' : 'ä¸­æ€§'} Ã— {' '}
            {currentEmotion.arousal > 0.3 ? 'ã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥' : 
             currentEmotion.arousal < -0.3 ? 'ç©ã‚„ã‹' : 'æ™®é€š'}
          </span>
        </div>
      </div>
    </div>
  );
};
```

### Step 2: ç¬æ™‚ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ (5åˆ†)

```typescript
// src/features/mood-input/InstantContentGenerator.ts
export class InstantContentGenerator {
  private readonly QUADRANT_CONTENT = {
    // é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼ Ã— ãƒã‚¸ãƒ†ã‚£ãƒ– (å³ä¸Š)
    energeticPositive: {
      title: "ã“ã®æ´»åŠ›ã‚’æ´»ã‹ã—ã¾ã—ã‚‡ã†",
      techniques: ["é›†ä¸­åŠ›å‘ä¸Šå‘¼å¸æ³•", "å‰µé€ æ€§æ´»æ€§åŒ–", "åŠ¹ç‡çš„ã‚¿ã‚¹ã‚¯å‡¦ç†"],
      audioProfile: "energizing",
      duration: 300
    },
    
    // ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼ Ã— ãƒã‚¸ãƒ†ã‚£ãƒ– (å³ä¸‹)  
    calmPositive: {
      title: "ç©ã‚„ã‹ãªæ™‚é–“ã‚’å¤§åˆ‡ã«",
      techniques: ["æ·±ã„ãƒªãƒ©ã‚¯ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³", "æ„Ÿè¬ã®ç‘æƒ³", "å¿ƒèº«ã®å……é›»"],
      audioProfile: "restoring", 
      duration: 300
    },
    
    // é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼ Ã— ãƒã‚¬ãƒ†ã‚£ãƒ– (å·¦ä¸Š)
    energeticNegative: {
      title: "ã“ã®æ°—æŒã¡ã‚’æ•´ç†ã—ã¾ã—ã‚‡ã†",
      techniques: ["æ€’ã‚Šã®ç®¡ç†æ³•", "ã‚¹ãƒˆãƒ¬ã‚¹ç™ºæ•£", "æ„Ÿæƒ…ã®ãƒªã‚»ãƒƒãƒˆ"],
      audioProfile: "calming",
      duration: 300
    },
    
    // ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼ Ã— ãƒã‚¬ãƒ†ã‚£ãƒ– (å·¦ä¸‹)
    calmNegative: {
      title: "å„ªã—ãå¿ƒã‚’ã‚±ã‚¢ã—ã¾ã›ã‚“ã‹",
      techniques: ["è‡ªå·±æ…ˆæ‚²ã®å®Ÿè·µ", "å¸Œæœ›ã®å›å¾©", "ã‚¨ãƒãƒ«ã‚®ãƒ¼è£œå……"],
      audioProfile: "nurturing",
      duration: 300
    }
  };

  generateInstantContent(emotion: EmotionalCoordinates): ContentRecommendation {
    const quadrant = this.determineQuadrant(emotion);
    const content = this.QUADRANT_CONTENT[quadrant];
    
    return {
      ...content,
      personalizedMessage: this.generatePersonalizedMessage(emotion),
      immediateAction: this.getImmediateAction(emotion)
    };
  }

  private determineQuadrant(emotion: EmotionalCoordinates): string {
    if (emotion.arousal > 0) {
      return emotion.valence > 0 ? 'energeticPositive' : 'energeticNegative';
    } else {
      return emotion.valence > 0 ? 'calmPositive' : 'calmNegative';
    }
  }

  private generatePersonalizedMessage(emotion: EmotionalCoordinates): string {
    const intensity = Math.sqrt(emotion.valence ** 2 + emotion.arousal ** 2);
    
    if (intensity < 0.3) {
      return "ä»Šã®æ°—æŒã¡ã‚’å¤§åˆ‡ã«ã€ãã®ã¾ã¾ã®è‡ªåˆ†ã‚’å—ã‘å…¥ã‚Œã¦ãã ã•ã„";
    } else if (intensity > 0.7) {
      return "å¼·ã„æ„Ÿæƒ…ã‚’æ„Ÿã˜ã¦ã„ã¾ã™ã­ã€‚ä¸€ç·’ã«æ•´ç†ã—ã¦ã„ãã¾ã—ã‚‡ã†";
    } else {
      return "ä»Šã®æ°—æŒã¡ã«å¯„ã‚Šæ·»ã„ãªãŒã‚‰ã€å¿ƒåœ°ã‚ˆã„æ™‚é–“ã‚’éã”ã—ã¾ã—ã‚‡ã†";
    }
  }
}
```

---

## ğŸ”§ å³åº§å®Ÿè£…ã®ãŸã‚ã®APIæ‹¡å¼µ

### Gemini APIæ‹¡å¼µ (5åˆ†)

```typescript
// api/gemini/reframing.ts (Vercel Function)
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { prompt } = await request.json();
    
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${process.env.GEMINI_API_KEY}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        },
        safetySettings: [
          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
        ]
      })
    });

    const data = await response.json();
    const content = data.candidates[0].content.parts[0].text;
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æ§‹é€ åŒ–ã—ã¦ãƒ‘ãƒ¼ã‚¹
    const structuredResponse = parseReframingResponse(content);
    
    return NextResponse.json(structuredResponse);
    
  } catch (error) {
    console.error('Gemini API Error:', error);
    return NextResponse.json(
      { error: 'ãƒªãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ' },
      { status: 500 }
    );
  }
}

function parseReframingResponse(content: string) {
  // Simple parser - æœ¬æ ¼å®Ÿè£…ã§ã¯è‡ªç„¶è¨€èªå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
  const lines = content.split('\n').filter(line => line.trim());
  
  return {
    script: lines[0] || "ä»Šã®æ°—æŒã¡ã«å¯„ã‚Šæ·»ã„ãªãŒã‚‰ã€ä¸€æ­©ãšã¤é€²ã‚“ã§ã„ãã¾ã—ã‚‡ã†ã€‚",
    questions: lines.slice(1, 4).length > 0 ? lines.slice(1, 4) : [
      "ã“ã®çŠ¶æ³ã§ã€ç¢ºå®Ÿã«è¨€ãˆã‚‹ã“ã¨ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ",
      "ã‚‚ã—å‹äººãŒåŒã˜çŠ¶æ³ãªã‚‰ã€ã©ã‚“ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ã—ã¾ã™ã‹ï¼Ÿ",
      "ã“ã®çµŒé¨“ã‹ã‚‰å­¦ã¹ã‚‹ã“ã¨ãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ"
    ],
    affirmation: lines[lines.length - 1] || "ã‚ãªãŸã¯ååˆ†é ‘å¼µã£ã¦ã„ã¾ã™ã€‚",
    followUp: [
      "å°‘ã—æ­©ã„ã¦ã¿ã‚‹",
      "æ¸©ã‹ã„é£²ã¿ç‰©ã‚’é£²ã‚€", 
      "å¥½ããªéŸ³æ¥½ã‚’èã"
    ]
  };
}
```

---

## ğŸ“± ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆå®Ÿè£… (10åˆ†)

```typescript
// src/pages/ReframingPage.tsx
import React, { useState, useCallback } from 'react';
import { EmotionCanvas } from '../components/advanced-ui/emotion-canvas/EmotionCanvas';
import { CognitiveReframingEngine, GeminiReframingService } from '../features/cognitive-reframing';

interface EmotionalCoordinates {
  valence: number;
  arousal: number;
}

export const ReframingPage: React.FC = () => {
  const [currentEmotion, setCurrentEmotion] = useState<EmotionalCoordinates>({ valence: 0, arousal: 0 });
  const [isGenerating, setIsGenerating] = useState(false);
  const [reframingContent, setReframingContent] = useState<any>(null);

  const reframingService = new GeminiReframingService();

  const handleEmotionSelection = useCallback(async (emotion: EmotionalCoordinates) => {
    setIsGenerating(true);
    
    try {
      // æ„Ÿæƒ…åº§æ¨™ã‚’ã‚«ãƒ†ã‚´ãƒªãƒ¼æ„Ÿæƒ…ã«å¤‰æ›
      const emotionType = convertCoordinatesToEmotion(emotion);
      
      const request = {
        emotionType,
        situation: 'general', // ã‚ˆã‚Šè©³ç´°ãªçŠ¶æ³é¸æŠã¯å¾Œç¶šãƒ•ã‚§ãƒ¼ã‚ºã§å®Ÿè£…
        intensity: Math.round(Math.sqrt(emotion.valence ** 2 + emotion.arousal ** 2) * 10),
        availableTime: 5,
        workContext: {
          isInOffice: true,
          canUseAudio: true,
          privacyLevel: 'medium' as const
        }
      };

      const response = await reframingService.generateReframing(request);
      setReframingContent(response);
      
    } catch (error) {
      console.error('Reframing generation failed:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…
      setReframingContent(generateFallbackContent(emotion));
    } finally {
      setIsGenerating(false);
    }
  }, [reframingService]);

  const convertCoordinatesToEmotion = (emotion: EmotionalCoordinates) => {
    if (emotion.arousal > 0.3 && emotion.valence < -0.3) return 'ã‚¤ãƒ©ã‚¤ãƒ©';
    if (emotion.arousal < -0.3 && emotion.valence < -0.3) return 'è½ã¡è¾¼ã¿';
    if (emotion.valence < -0.3) return 'ãƒ¢ãƒ¤ãƒ¢ãƒ¤';
    if (emotion.arousal < -0.3) return 'ç–²ã‚Œ';
    return 'ãƒ¢ãƒ¤ãƒ¢ãƒ¤'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4">
      <div className="max-w-2xl mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-800 mb-2">
            ä»Šã®æ°—æŒã¡ã‚’æ•™ãˆã¦ãã ã•ã„
          </h1>
          <p className="text-gray-600">
            æ„Ÿæƒ…ã®ä½ç½®ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã€ã‚ãªãŸã«æœ€é©ãªæ°—æ™´ã‚‰ã—ã‚’è¦‹ã¤ã‘ã¾ã—ã‚‡ã†
          </p>
        </div>

        <div className="bg-white rounded-2xl shadow-xl p-6 mb-6">
          <EmotionCanvas
            onEmotionChange={setCurrentEmotion}
            onSelectionComplete={handleEmotionSelection}
          />
        </div>

        {isGenerating && (
          <div className="bg-white rounded-2xl shadow-xl p-6 text-center">
            <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
            <p className="text-gray-600">ã‚ãªãŸã«æœ€é©ãªæ°—æ™´ã‚‰ã—ã‚’æº–å‚™ã—ã¦ã„ã¾ã™...</p>
          </div>
        )}

        {reframingContent && (
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <h2 className="text-xl font-semibold text-gray-800 mb-4">
              {reframingContent.strategy.name}
            </h2>
            
            <div className="space-y-4">
              <div className="p-4 bg-purple-50 rounded-lg">
                <p className="text-gray-700">{reframingContent.personalizedScript}</p>
              </div>
              
              <div className="p-4 bg-blue-50 rounded-lg">
                <p className="text-sm font-medium text-blue-800 mb-2">å‘¼å¸ã®ã‚³ãƒ„:</p>
                <p className="text-blue-700">{reframingContent.breathingCue}</p>
              </div>
              
              <div className="p-4 bg-green-50 rounded-lg">
                <p className="text-sm font-medium text-green-800 mb-2">ä»Šæ—¥ã®è¨€è‘‰:</p>
                <p className="text-green-700 font-medium">{reframingContent.affirmation}</p>
              </div>

              <button className="w-full bg-purple-600 text-white py-3 px-6 rounded-lg font-medium hover:bg-purple-700 transition-colors">
                éŸ³å£°ã‚¬ã‚¤ãƒ‰ã‚’é–‹å§‹
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

function generateFallbackContent(emotion: EmotionalCoordinates) {
  return {
    strategy: { name: "åŸºæœ¬çš„ãªå¿ƒã®ã‚±ã‚¢" },
    personalizedScript: "ä»Šæ„Ÿã˜ã¦ã„ã‚‹æ°—æŒã¡ã‚’ãã®ã¾ã¾å—ã‘å…¥ã‚Œã¦ã€æ·±å‘¼å¸ã‚’ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚",
    breathingCue: "4ç§’å¸ã£ã¦ã€6ç§’ã§æ¯ã‚’åã„ã¦ãã ã•ã„ã€‚",
    affirmation: "ä»Šã®ã‚ãªãŸã§ååˆ†ã§ã™ã€‚"
  };
}
```

---

## ğŸš€ å³åº§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# æ–°æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run dev

# åˆ¥ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§å˜ä½“ãƒ†ã‚¹ãƒˆ
npm test -- --watch --testPathPattern="cognitive-reframing|mood-input"

# ESLintãƒã‚§ãƒƒã‚¯
npm run lint

# TypeScriptãƒã‚§ãƒƒã‚¯  
npm run type-check

echo "ğŸ‰ Phase 4.1 åŸºç›¤å®Ÿè£…å®Œäº†ï¼ http://localhost:3000/reframing ã§ç¢ºèª"
```

---

## ğŸ“ˆ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

### ä»Šæ—¥ä¸­ã«å®Œäº†ã™ã¹ãä½œæ¥­
1. âœ… ãƒã‚¬ãƒ†ã‚£ãƒ–æ„Ÿæƒ…ãƒªãƒ•ãƒ¬ãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—
2. âœ… ã‚¼ãƒ­UIãƒ ãƒ¼ãƒ‰å…¥åŠ›ã®åŸºæœ¬å®Ÿè£…
3. âœ… Geminiçµ±åˆãƒ†ã‚¹ãƒˆ

### æ˜æ—¥ã®ä½œæ¥­äºˆå®š
1. ğŸ”„ éŸ³å£°SSMLç”Ÿæˆã®é«˜åº¦åŒ–
2. ğŸ”„ åŠ¹æœæ¸¬å®šã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…
3. ğŸ”„ ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã®æº–å‚™

### 1é€±é–“å¾Œã®ç›®æ¨™
1. ğŸ¯ Phase 4.1 å®Œå…¨ç‰ˆãƒªãƒªãƒ¼ã‚¹
2. ğŸ¯ åˆæœŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹
3. ğŸ¯ Phase 4.2 è¨­è¨ˆç€æ‰‹

**ä»Šã™ãã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦å®Ÿè£…ã‚’é–‹å§‹ã—ã€ä¸–ç•Œåˆã®è·å ´çµ±åˆå‹ãƒã‚¤ã‚¯ãƒ­ã‚¦ã‚§ãƒ«ãƒã‚¹ä½“é¨“ã‚’å®Ÿç¾ã—ã¾ã—ã‚‡ã†ï¼** ğŸš€